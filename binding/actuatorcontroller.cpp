#include <actuatorcontroller.h>
#include <functional>
#include <iterator>
#include <memory>
#include <sstream> // __str__
#include <string>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include "actuatordefine.h"
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_actuatorcontroller(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // ActuatorController file:actuatorcontroller.h line:32
		pybind11::class_<ActuatorController, std::shared_ptr<ActuatorController>> cl(M(""), "ActuatorController", "The ActuatorController class 执行器控制器类，所有与执行器相关的操作都在此类中");
		cl.def_static("initController", (class ActuatorController * (*)()) &ActuatorController::initController, "初始化控制器，使用控制器之前必须先初始化\n\nC++: ActuatorController::initController() --> class ActuatorController *", pybind11::return_value_policy::automatic);
		cl.def("lookupActuators", (class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> > (ActuatorController::*)(enum Actuator::ErrorsDefine &)) &ActuatorController::lookupActuators, "查找所有已连接的执行器\n \n\n 错误代码，如果找不到可用执行器，返回对应错误代码\n \n\n 返回所有查找到的执行器的UnifiedID\n \n\n 查找执行器需要花费一定时间\n\nC++: ActuatorController::lookupActuators(enum Actuator::ErrorsDefine &) --> class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> >", pybind11::arg("ec"));
		cl.def_static("getInstance", (class ActuatorController * (*)()) &ActuatorController::getInstance, "获取控制器对象\n \n\n 控制器对象\n\nC++: ActuatorController::getInstance() --> class ActuatorController *", pybind11::return_value_policy::automatic);
		cl.def_static("processEvents", (void (*)()) &ActuatorController::processEvents, "处理控制器事件\n\nC++: ActuatorController::processEvents() --> void");
		cl.def("hasAvailableActuator", (bool (ActuatorController::*)() const) &ActuatorController::hasAvailableActuator, "是否有可用执行器\n\nC++: ActuatorController::hasAvailableActuator() const --> bool");
		cl.def("getActuatorIdArray", (class std::vector<unsigned char, class std::allocator<unsigned char> > (ActuatorController::*)() const) &ActuatorController::getActuatorIdArray, "获取所有执行器Id数组\n \n\n id数组\n\nC++: ActuatorController::getActuatorIdArray() const --> class std::vector<unsigned char, class std::allocator<unsigned char> >");
		cl.def("getActuatorUnifiedIDArray", (class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> > (ActuatorController::*)() const) &ActuatorController::getActuatorUnifiedIDArray, "获取所有执行器UnifiedID数组\n \n\n UnifiedID数组\n\nC++: ActuatorController::getActuatorUnifiedIDArray() const --> class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> >");
		cl.def("getUnifiedIDGroup", (class std::vector<unsigned char, class std::allocator<unsigned char> > (ActuatorController::*)(const std::string &)) &ActuatorController::getUnifiedIDGroup, "getUnifiedIDGroup getUnifiedIDGroup 获取指定ip地址下所有执行器的UnifiedID\n \n\n ip地址的字符串\n \n\n 返回同一通信单元内的所有执行器ID\n\nC++: ActuatorController::getUnifiedIDGroup(const std::string &) --> class std::vector<unsigned char, class std::allocator<unsigned char> >", pybind11::arg("ipAddress"));
		cl.def("enableAllActuators", (bool (ActuatorController::*)()) &ActuatorController::enableAllActuators, "使能所有执行器\n \n\n 全部使能成功返回true，否则返回false\n\nC++: ActuatorController::enableAllActuators() --> bool");
		cl.def("disableAllActuators", (bool (ActuatorController::*)()) &ActuatorController::disableAllActuators, "失能所有执行器\n \n\n 全部失能成功返回true，否则返回false\n\nC++: ActuatorController::disableAllActuators() --> bool");
		cl.def("enableActuator", [](ActuatorController &o, unsigned char const & a0) -> bool { return o.enableActuator(a0); }, "", pybind11::arg("id"));
		cl.def("enableActuator", (bool (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::enableActuator, "使能指定执行器\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n\n\n\nC++: ActuatorController::enableActuator(unsigned char, const std::string &) --> bool", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("enableActuatorInBatch", (bool (ActuatorController::*)(const class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> > &)) &ActuatorController::enableActuatorInBatch, "使能指定执行器\n \n\n 执行器UnifiedID数组\n \n\n 执行器使能成功返回true,否则返回false\n\nC++: ActuatorController::enableActuatorInBatch(const class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> > &) --> bool", pybind11::arg("unifiedIDArray"));
		cl.def("disableActuator", [](ActuatorController &o, unsigned char const & a0) -> bool { return o.disableActuator(a0); }, "", pybind11::arg("id"));
		cl.def("disableActuator", (bool (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::disableActuator, "失能指定执行器\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 执行器失能成功返回true,否则返回false\n\nC++: ActuatorController::disableActuator(unsigned char, const std::string &) --> bool", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("activateActuatorMode", [](ActuatorController &o, unsigned char const & a0, const enum Actuator::ActuatorMode & a1) -> void { return o.activateActuatorMode(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("nMode"));
		cl.def("activateActuatorMode", (void (ActuatorController::*)(unsigned char, const enum Actuator::ActuatorMode, const std::string &)) &ActuatorController::activateActuatorMode, "activateActuatorMode 激活单个执行器的指定模式\n \n\n 执行器id\n \n\n 指定的激活模式\n * \n\n 目标ip地址字符串\n\nC++: ActuatorController::activateActuatorMode(unsigned char, const enum Actuator::ActuatorMode, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("nMode"), pybind11::arg("ipAddress"));
		cl.def("activateActuatorModeInBantch", (void (ActuatorController::*)(class std::vector<unsigned char, class std::allocator<unsigned char> >, const enum Actuator::ActuatorMode)) &ActuatorController::activateActuatorModeInBantch, "激活执行器的指定模式\n \n\n 执行器id数组\n \n\n 要激活的模式\n\nC++: ActuatorController::activateActuatorModeInBantch(class std::vector<unsigned char, class std::allocator<unsigned char> >, const enum Actuator::ActuatorMode) --> void", pybind11::arg("idArray"), pybind11::arg("nMode"));
		cl.def("activateActuatorModeInBantch", (void (ActuatorController::*)(class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> >, const enum Actuator::ActuatorMode)) &ActuatorController::activateActuatorModeInBantch, "激活执行器的指定模式\n \n\n 执行器UnifiedID数组\n \n\n 要激活的模式\n\nC++: ActuatorController::activateActuatorModeInBantch(class std::vector<struct ActuatorController::UnifiedID, class std::allocator<struct ActuatorController::UnifiedID> >, const enum Actuator::ActuatorMode) --> void", pybind11::arg("UnifiedIDArray"), pybind11::arg("nMode"));
		cl.def("switchAutoRefresh", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> void { return o.switchAutoRefresh(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bOpen"));
		cl.def("switchAutoRefresh", (void (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::switchAutoRefresh, "开启或关闭执行器自动刷新功能，自动请求执行器电流、速度、位置、电压、温度、逆变器温度（默认关闭此功能）\n \n\n 执行器id\n \n\n 是否开启\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::switchAutoRefresh(unsigned char, bool, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("bOpen"), pybind11::arg("ipAddress"));
		cl.def("setAutoRefreshInterval", [](ActuatorController &o, unsigned char const & a0, unsigned int const & a1) -> void { return o.setAutoRefreshInterval(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("mSec"));
		cl.def("setAutoRefreshInterval", (void (ActuatorController::*)(unsigned char, unsigned int, const std::string &)) &ActuatorController::setAutoRefreshInterval, "设置自动刷新时间间隔（默认时间间隔为1s）\n \n\n 执行器id\n \n\n 毫秒数\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setAutoRefreshInterval(unsigned char, unsigned int, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("mSec"), pybind11::arg("ipAddress"));
		cl.def("setPosition", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("pos"));
		cl.def("setPosition", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPosition, "设置位置\n \n\n 执行器id\n \n\n 目标位置，单位是圈数\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPosition(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("pos"), pybind11::arg("ipAddress"));
		cl.def("getPosition", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPosition", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPosition, "获取当前位置\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次位置读取,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前位置，单位是转数\n\nC++: ActuatorController::getPosition(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionKp", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionKp(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("Kp"));
		cl.def("setPositionKp", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionKp, "设置位置环的比例\n \n\n 执行器id\n \n\n 位置环的比例\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionKp(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("Kp"), pybind11::arg("ipAddress"));
		cl.def("getPositionKp", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionKp(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionKp", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionKp, "获取位置环的比例\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次位置环的比例,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的比例\n\nC++: ActuatorController::getPositionKp(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionKi", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionKi(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("Ki"));
		cl.def("setPositionKi", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionKi, "设置位置环的积分\n \n\n 执行器id\n \n\n 位置环的积分\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionKi(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("Ki"), pybind11::arg("ipAddress"));
		cl.def("getPositionKi", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionKi(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionKi", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionKi, "获取位置环的积分\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次位置环的积分,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的积分\n\nC++: ActuatorController::getPositionKi(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionKd", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionKd(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("Kd"));
		cl.def("setPositionKd", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionKd, "设置位置环的微分\n \n\n 执行器id\n \n\n 位置环的微分\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionKd(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("Kd"), pybind11::arg("ipAddress"));
		cl.def("getPositionKd", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionKd(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionKd", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionKd, "获取位置环的微分\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次位置环的微分,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的微分\n\nC++: ActuatorController::getPositionKd(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionUmax", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionUmax(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("max"));
		cl.def("setPositionUmax", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionUmax, "设置位置环的最大输出限幅\n \n\n 执行器id\n \n\n 位置环的最大输出限幅,有效值范围为(0,1]\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionUmax(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("max"), pybind11::arg("ipAddress"));
		cl.def("getPositionUmax", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionUmax(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionUmax", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionUmax, "获取位置环的最大输出限幅\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次最大输出限幅,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的最大输出限幅\n\nC++: ActuatorController::getPositionUmax(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionUmin", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionUmin(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("min"));
		cl.def("setPositionUmin", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionUmin, "设置位置环的最小输出限幅\n \n\n 执行器id\n \n\n 位置环的最小输出限幅,有效值范围为[-1,0)\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionUmin(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("min"), pybind11::arg("ipAddress"));
		cl.def("getPositionUmin", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionUmin(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionUmin", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionUmin, "获取位置环的最小输出限幅\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次最小输出限幅,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的最小输出限幅\n\nC++: ActuatorController::getPositionUmin(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionOffset", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionOffset(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("offset"));
		cl.def("setPositionOffset", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionOffset, "设置位置环的限位偏移\n \n\n 执行器id\n \n\n 位置环的限位偏移\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionOffset(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("offset"), pybind11::arg("ipAddress"));
		cl.def("getPositionOffset", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionOffset(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionOffset", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionOffset, "获取位置环的限位偏移\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次限位偏移,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的限位偏移\n\nC++: ActuatorController::getPositionOffset(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setMaximumPosition", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setMaximumPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("maxPos"));
		cl.def("setMaximumPosition", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setMaximumPosition, "设置位置环的最大限位\n \n\n 执行器id\n \n\n 位置环的最大限位\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setMaximumPosition(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("maxPos"), pybind11::arg("ipAddress"));
		cl.def("getMaximumPosition", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getMaximumPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getMaximumPosition", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getMaximumPosition, "获取位置环的最大限位\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次最大限位,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的最大限位\n\nC++: ActuatorController::getMaximumPosition(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setMinimumPosition", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setMinimumPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("minPos"));
		cl.def("setMinimumPosition", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setMinimumPosition, "设置位置环的最小限位\n \n\n 执行器id\n \n\n 位置环的最小限位\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setMinimumPosition(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("minPos"), pybind11::arg("ipAddress"));
		cl.def("getMinimumPosition", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getMinimumPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getMinimumPosition", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getMinimumPosition, "获取位置环的最小限位\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次最小限位,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环的最小限位\n\nC++: ActuatorController::getMinimumPosition(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("enablePositionLimit", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> void { return o.enablePositionLimit(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("enable"));
		cl.def("enablePositionLimit", (void (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::enablePositionLimit, "使能/失能执行器限位功能，失能后速度模式和电流模式将不受限位影响\n \n\n 执行器id\n \n\n 使能/失能\n \n\n ipAddress 目标ip地址字符串\n\nC++: ActuatorController::enablePositionLimit(unsigned char, bool, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("enable"), pybind11::arg("ipAddress"));
		cl.def("isPositionLimitEnable", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> bool { return o.isPositionLimitEnable(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("isPositionLimitEnable", (bool (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::isPositionLimitEnable, "读取执行器限位功能使能/失能\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次限位功能使能/失能,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n\n\n\nC++: ActuatorController::isPositionLimitEnable(unsigned char, bool, const std::string &) const --> bool", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setHomingPosition", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setHomingPosition(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("homingPos"));
		cl.def("setHomingPosition", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setHomingPosition, "设置执行器的零位\n \n\n 执行器id\n \n\n 执行器的零位\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setHomingPosition(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("homingPos"), pybind11::arg("ipAddress"));
		cl.def("enablePositionFilter", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> void { return o.enablePositionFilter(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("enable"));
		cl.def("enablePositionFilter", (void (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::enablePositionFilter, "使能/失能位置环滤波功能，该功能为一阶低通滤波\n \n\n 执行器id\n \n\n 使能/失能\n \n\n ipAddress 目标ip地址字符串\n\nC++: ActuatorController::enablePositionFilter(unsigned char, bool, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("enable"), pybind11::arg("ipAddress"));
		cl.def("isPositionFilterEnable", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> bool { return o.isPositionFilterEnable(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("isPositionFilterEnable", (bool (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::isPositionFilterEnable, "读取执位置环滤波功能使能/失能\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次位置环滤波功能使能/失能,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n\n\n\nC++: ActuatorController::isPositionFilterEnable(unsigned char, bool, const std::string &) const --> bool", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getPositionCutoffFrequency", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getPositionCutoffFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getPositionCutoffFrequency", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getPositionCutoffFrequency, "获取位置环低通滤波频率\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次低通滤波频率,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 位置环低通滤波频率\n\nC++: ActuatorController::getPositionCutoffFrequency(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setPositionCutoffFrequency", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setPositionCutoffFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("frequency"));
		cl.def("setPositionCutoffFrequency", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setPositionCutoffFrequency, "设置位置环低通滤波频率\n \n\n 执行器id\n \n\n 位置环低通滤波频率\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setPositionCutoffFrequency(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("frequency"), pybind11::arg("ipAddress"));
		cl.def("clearHomingInfo", [](ActuatorController &o, unsigned char const & a0) -> void { return o.clearHomingInfo(a0); }, "", pybind11::arg("id"));
		cl.def("clearHomingInfo", (void (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::clearHomingInfo, "清除homing信息，包括左右极限和0位\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::clearHomingInfo(unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("setProfilePositionAcceleration", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setProfilePositionAcceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("acceleration"));
		cl.def("setProfilePositionAcceleration", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setProfilePositionAcceleration, "设置Profile position模式的加速度\n \n\n 执行器id\n \n\n Profile position模式的加速度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setProfilePositionAcceleration(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("acceleration"), pybind11::arg("ipAddress"));
		cl.def("getProfilePositionAcceleration", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getProfilePositionAcceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getProfilePositionAcceleration", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getProfilePositionAcceleration, "获取Profile position模式的加速度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次Profile position模式的加速度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n Profile position模式的加速度\n\nC++: ActuatorController::getProfilePositionAcceleration(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setProfilePositionDeceleration", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setProfilePositionDeceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("deceleration"));
		cl.def("setProfilePositionDeceleration", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setProfilePositionDeceleration, "设置Profile position模式的减速度\n \n\n 执行器id\n \n\n Profile position模式的减速度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setProfilePositionDeceleration(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("deceleration"), pybind11::arg("ipAddress"));
		cl.def("getProfilePositionDeceleration", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getProfilePositionDeceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getProfilePositionDeceleration", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getProfilePositionDeceleration, "获取Profile position模式的减速度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次Profile position模式的减速度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n Profile position模式的减速度\n\nC++: ActuatorController::getProfilePositionDeceleration(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setProfilePositionMaxVelocity", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setProfilePositionMaxVelocity(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("maxVelocity"));
		cl.def("setProfilePositionMaxVelocity", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setProfilePositionMaxVelocity, "设置Profile position模式的最大速度\n \n\n 执行器id\n \n\n Profile position模式的最大速度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setProfilePositionMaxVelocity(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("maxVelocity"), pybind11::arg("ipAddress"));
		cl.def("getProfilePositionMaxVelocity", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getProfilePositionMaxVelocity(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getProfilePositionMaxVelocity", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getProfilePositionMaxVelocity, "获取Profile position模式的最大速度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次Profile position模式的最大速度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n Profile position模式的最大速度\n\nC++: ActuatorController::getProfilePositionMaxVelocity(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setVelocity", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocity(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("vel"));
		cl.def("setVelocity", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocity, "设置速度\n \n\n 执行器id\n \n\n 目标速度，单位是转/每分钟\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setVelocity(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("vel"), pybind11::arg("ipAddress"));
		cl.def("getVelocity", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocity(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocity", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocity, "获取当前速度\n \n\n 执行器id\n \n\n 是否需要刷新,如果为true，会自动请求一次速度读取,并等待返回，如果为false,则会立即返回最近一次请求速度返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前速度，单位是转/每分钟\n\nC++: ActuatorController::getVelocity(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getVelocityKp", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityKp(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityKp", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityKp, "获取速度环比例\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次速度环比例读取,并等待返回，如果为false,则会立即返回最近一次请求速度环比例返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前速度环比例\n\nC++: ActuatorController::getVelocityKp(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setVelocityKp", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocityKp(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("Kp"));
		cl.def("setVelocityKp", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocityKp, "设置速度环比例\n \n\n 执行器id\n \n\n 速度环比例\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setVelocityKp(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("Kp"), pybind11::arg("ipAddress"));
		cl.def("getVelocityKi", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityKi(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityKi", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityKi, "获取速度环积分\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次速度环积分读取,并等待返回，如果为false,则会立即返回最近一次请求速度环积分返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前速度环积分\n\nC++: ActuatorController::getVelocityKi(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setVelocityKi", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocityKi(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("Ki"));
		cl.def("setVelocityKi", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocityKi, "setVelocityKi 设置速度环积分\n \n\n 执行器id\n \n\n 积分\n \n\n 目标ip地址字符串\n \n\n 设置成功或失败\n\nC++: ActuatorController::setVelocityKi(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("Ki"), pybind11::arg("ipAddress"));
		cl.def("getVelocityUmax", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityUmax(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityUmax", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityUmax, "获取速度环最大输出限幅\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次速度环最大输出限幅读取,并等待返回，如果为false,则会立即返回最近一次请求速度环最大输出限幅返回的结果\n \n\n 目标ip地址字符串\n \n\n 最大输出限幅\n\nC++: ActuatorController::getVelocityUmax(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setVelocityUmax", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocityUmax(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("max"));
		cl.def("setVelocityUmax", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocityUmax, "设置速度环最大输出限幅\n \n\n 执行器id\n \n\n 最大输出限幅,有效值范围为（0,1]\n \n\n 目标ip地址字符串\n \n\n 设置成功或失败\n\nC++: ActuatorController::setVelocityUmax(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("max"), pybind11::arg("ipAddress"));
		cl.def("getVelocityUmin", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityUmin(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityUmin", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityUmin, "获取速度环最小输出限幅\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次速度环最小输出限幅读取,并等待返回，如果为false,则会立即返回最近一次请求速度环最小输出限幅返回的结果\n \n\n 目标ip地址字符串\n \n\n 最小输出限幅\n\nC++: ActuatorController::getVelocityUmin(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setVelocityUmin", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocityUmin(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("min"));
		cl.def("setVelocityUmin", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocityUmin, "设置速度环最小输出限幅\n \n\n 执行器id\n \n\n 最小输出限幅,有效值范围为[-1,0)\n \n\n 目标ip地址字符串\n \n\n 设置成功或失败\n\nC++: ActuatorController::setVelocityUmin(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("min"), pybind11::arg("ipAddress"));
		cl.def("getVelocityRange", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityRange(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityRange", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityRange, "获取执行器速度量程，单位RPM\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次执行器速度量程,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 执行器速度量程\n\nC++: ActuatorController::getVelocityRange(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("enableVelocityFilter", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> void { return o.enableVelocityFilter(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("enable"));
		cl.def("enableVelocityFilter", (void (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::enableVelocityFilter, "使能/失能速度环滤波功能，该功能为一阶低通滤波\n \n\n 执行器id\n \n\n 使能/失能\n \n\n ipAddress 目标ip地址字符串\n\nC++: ActuatorController::enableVelocityFilter(unsigned char, bool, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("enable"), pybind11::arg("ipAddress"));
		cl.def("isVelocityFilterEnable", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> bool { return o.isVelocityFilterEnable(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("isVelocityFilterEnable", (bool (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::isVelocityFilterEnable, "读取执速度环滤波功能使能/失能\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次速度环滤波功能使能/失能,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 速度环滤波功能使能/失能\n\nC++: ActuatorController::isVelocityFilterEnable(unsigned char, bool, const std::string &) const --> bool", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getVelocityCutoffFrequency", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityCutoffFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityCutoffFrequency", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityCutoffFrequency, "获取速度环低通滤波频率\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次低通滤波频率,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 速度环低通滤波频率\n\nC++: ActuatorController::getVelocityCutoffFrequency(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setVelocityCutoffFrequency", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocityCutoffFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("frequency"));
		cl.def("setVelocityCutoffFrequency", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocityCutoffFrequency, "设置速度环低通滤波频率\n \n\n 执行器id\n \n\n 速度环低通滤波频率\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setVelocityCutoffFrequency(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("frequency"), pybind11::arg("ipAddress"));
		cl.def("setVelocityLimit", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setVelocityLimit(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("limit"));
		cl.def("setVelocityLimit", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setVelocityLimit, "设置执行器速度限制\n \n\n 执行器id\n \n\n 执行器速度限制，单位是RPM,该值不会超过速度量程\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setVelocityLimit(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("limit"), pybind11::arg("ipAddress"));
		cl.def("getVelocityLimit", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVelocityLimit(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVelocityLimit", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVelocityLimit, "获取执行器速度限制\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次执行器速度限制,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 执行器速度限制\n\nC++: ActuatorController::getVelocityLimit(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setProfileVelocityAcceleration", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setProfileVelocityAcceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("acceleration"));
		cl.def("setProfileVelocityAcceleration", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setProfileVelocityAcceleration, "设置Profile velocity模式的加速度\n \n\n 执行器id\n \n\n Profile velocity模式的加速度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setProfileVelocityAcceleration(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("acceleration"), pybind11::arg("ipAddress"));
		cl.def("getProfileVelocityAcceleration", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getProfileVelocityAcceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getProfileVelocityAcceleration", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getProfileVelocityAcceleration, "获取Profile velocity模式的加速度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次Profile velocity模式的加速度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n Profile velocity模式的加速度\n\nC++: ActuatorController::getProfileVelocityAcceleration(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setProfileVelocityDeceleration", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setProfileVelocityDeceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("deceleration"));
		cl.def("setProfileVelocityDeceleration", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setProfileVelocityDeceleration, "设置Profile velocity模式的减速度\n \n\n 执行器id\n \n\n Profile velocity模式的减速度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setProfileVelocityDeceleration(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("deceleration"), pybind11::arg("ipAddress"));
		cl.def("getProfileVelocityDeceleration", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getProfileVelocityDeceleration(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getProfileVelocityDeceleration", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getProfileVelocityDeceleration, "获取Profile velocity模式的减速度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次Profile velocity模式的减速度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n Profile velocity模式的减速度\n\nC++: ActuatorController::getProfileVelocityDeceleration(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setCurrent", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setCurrent(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("current"));
		cl.def("setCurrent", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setCurrent, "设置电流\n \n\n 执行器id\n \n\n 目标电流，单位是A\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setCurrent(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("current"), pybind11::arg("ipAddress"));
		cl.def("getCurrent", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getCurrent(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getCurrent", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getCurrent, "获取当前电流\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电流读取,并等待返回，如果为false,则会立即返回最近一次请求电流返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前电流，单位是A\n\nC++: ActuatorController::getCurrent(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getCurrentKp", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getCurrentKp(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getCurrentKp", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getCurrentKp, "获取电流环比例\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电流环比例读取,并等待返回，如果为false,则会立即返回最近一次请求电流环比例返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前电流环比例\n\nC++: ActuatorController::getCurrentKp(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getCurrentKi", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getCurrentKi(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getCurrentKi", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getCurrentKi, "获取电流环积分\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电流环积分读取,并等待返回，如果为false,则会立即返回最近一次请求电流环积分返回的结果\n \n\n 目标ip地址字符串\n \n\n 当前电流环积分\n\nC++: ActuatorController::getCurrentKi(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getCurrentRange", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getCurrentRange(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getCurrentRange", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getCurrentRange, "获取执行器电流量程，单位A\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次执行器电流量程,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 执行器电流量程\n\nC++: ActuatorController::getCurrentRange(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("enableCurrentFilter", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> void { return o.enableCurrentFilter(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("enable"));
		cl.def("enableCurrentFilter", (void (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::enableCurrentFilter, "使能/失能电流环滤波功能，该功能为一阶低通滤波\n \n\n 执行器id\n \n\n 使能/失能\n \n\n ipAddress 目标ip地址字符串\n\nC++: ActuatorController::enableCurrentFilter(unsigned char, bool, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("enable"), pybind11::arg("ipAddress"));
		cl.def("isCurrentFilterEnable", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> bool { return o.isCurrentFilterEnable(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("isCurrentFilterEnable", (bool (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::isCurrentFilterEnable, "读取执电流环滤波功能使能/失能\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电流环滤波功能使能/失能,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 电流环滤波功能使能/失能\n\nC++: ActuatorController::isCurrentFilterEnable(unsigned char, bool, const std::string &) const --> bool", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getCurrentCutoffFrequency", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getCurrentCutoffFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getCurrentCutoffFrequency", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getCurrentCutoffFrequency, "获取电流环低通滤波频率\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次低通滤波频率,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 电流环低通滤波频率\n\nC++: ActuatorController::getCurrentCutoffFrequency(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setCurrentCutoffFrequency", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setCurrentCutoffFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("frequency"));
		cl.def("setCurrentCutoffFrequency", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setCurrentCutoffFrequency, "设置电流环低通滤波频率\n \n\n 执行器id\n \n\n 电流环低通滤波频率\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setCurrentCutoffFrequency(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("frequency"), pybind11::arg("ipAddress"));
		cl.def("setCurrentLimit", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setCurrentLimit(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("limit"));
		cl.def("setCurrentLimit", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setCurrentLimit, "设置执行器电流限制\n \n\n 执行器id\n \n\n 执行器电流限制,单位是A，该值不会超过电流量程\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setCurrentLimit(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("limit"), pybind11::arg("ipAddress"));
		cl.def("getCurrentLimit", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getCurrentLimit(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getCurrentLimit", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getCurrentLimit, "获取执行器电流限制\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次执行器电流限制,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 执行器电流限制\n\nC++: ActuatorController::getCurrentLimit(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("saveAllParams", [](ActuatorController &o, unsigned char const & a0) -> bool { return o.saveAllParams(a0); }, "", pybind11::arg("id"));
		cl.def("saveAllParams", (bool (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::saveAllParams, "执行器保存当前所有参数,如果修改参数以后没有保存，失能后将丢弃参数修改\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 保存成功返回true,否则返回false\n\nC++: ActuatorController::saveAllParams(unsigned char, const std::string &) --> bool", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("setChartFrequency", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setChartFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("frequency"));
		cl.def("setChartFrequency", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setChartFrequency, "C++: ActuatorController::setChartFrequency(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("frequency"), pybind11::arg("ipAddress"));
		cl.def("getChartFrequency", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getChartFrequency(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getChartFrequency", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getChartFrequency, "C++: ActuatorController::getChartFrequency(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setChartThreshold", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setChartThreshold(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("threshold"));
		cl.def("setChartThreshold", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setChartThreshold, "C++: ActuatorController::setChartThreshold(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("threshold"), pybind11::arg("ipAddress"));
		cl.def("getChartThreshold", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getChartThreshold(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getChartThreshold", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getChartThreshold, "C++: ActuatorController::getChartThreshold(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("enableChart", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> void { return o.enableChart(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("enable"));
		cl.def("enableChart", (void (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::enableChart, "C++: ActuatorController::enableChart(unsigned char, bool, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("enable"), pybind11::arg("ipAddress"));
		cl.def("isChartEnable", [](ActuatorController &o, unsigned char const & a0, bool const & a1) -> bool { return o.isChartEnable(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("isChartEnable", (bool (ActuatorController::*)(unsigned char, bool, const std::string &)) &ActuatorController::isChartEnable, "C++: ActuatorController::isChartEnable(unsigned char, bool, const std::string &) --> bool", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("openChartChannel", [](ActuatorController &o, unsigned char const & a0, unsigned char const & a1) -> void { return o.openChartChannel(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("nChannelId"));
		cl.def("openChartChannel", (void (ActuatorController::*)(unsigned char, unsigned char, const std::string &)) &ActuatorController::openChartChannel, "开启图表指定通道\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 通道id（Actuator::channel_1到Actuator::channel_4）\n\nC++: ActuatorController::openChartChannel(unsigned char, unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("nChannelId"), pybind11::arg("ipAddress"));
		cl.def("closeChartChannel", [](ActuatorController &o, unsigned char const & a0, unsigned char const & a1) -> void { return o.closeChartChannel(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("nChannelId"));
		cl.def("closeChartChannel", (void (ActuatorController::*)(unsigned char, unsigned char, const std::string &)) &ActuatorController::closeChartChannel, "关闭图表指定通道\n \n\n 执行器id\n \n\n 通道id（Actuator::channel_1到Actuator::channel_4）\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::closeChartChannel(unsigned char, unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("nChannelId"), pybind11::arg("ipAddress"));
		cl.def("setCurrentChartMode", (void (ActuatorController::*)(unsigned char, unsigned char)) &ActuatorController::setCurrentChartMode, "setCurrentChartMode 设置电流模式图显模式，有Actuator::IQ_CHART和Actuator::ID_CHART两种模式\n \n\n 执行器id\n \n\n 图显模式\n\nC++: ActuatorController::setCurrentChartMode(unsigned char, unsigned char) --> void", pybind11::arg("id"), pybind11::arg("mode"));
		cl.def("setCurrentChartMode", (void (ActuatorController::*)(unsigned long, unsigned char)) &ActuatorController::setCurrentChartMode, "setCurrentChartMode 设置电流模式图显模式，有Actuator::IQ_CHART和Actuator::ID_CHART两种模式\n \n\n 执行器长id\n \n\n 图显模式\n\nC++: ActuatorController::setCurrentChartMode(unsigned long, unsigned char) --> void", pybind11::arg("longId"), pybind11::arg("mode"));
		cl.def("getVoltage", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getVoltage(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getVoltage", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getVoltage, "获取执行器电压\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次执行器电压,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 执行器电压\n\nC++: ActuatorController::getVoltage(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getLockEnergy", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getLockEnergy(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getLockEnergy", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getLockEnergy, "获取执行器堵转能量\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次执行器堵转能量,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 执行器堵转能量，单位J\n\nC++: ActuatorController::getLockEnergy(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setLockEnergy", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setLockEnergy(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("energy"));
		cl.def("setLockEnergy", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setLockEnergy, "设置执行器堵转能量\n \n\n 执行器id\n \n\n 执行器堵转能量，单位J\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setLockEnergy(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("energy"), pybind11::arg("ipAddress"));
		cl.def("getMotorTemperature", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getMotorTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getMotorTemperature", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getMotorTemperature, "获取电机温度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电机温度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 电机温度,单位℃\n\nC++: ActuatorController::getMotorTemperature(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getInverterTemperature", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getInverterTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getInverterTemperature", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getInverterTemperature, "获取逆变器温度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次逆变器温度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 逆变器温度,单位℃\n\nC++: ActuatorController::getInverterTemperature(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("getMotorProtectedTemperature", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getMotorProtectedTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getMotorProtectedTemperature", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getMotorProtectedTemperature, "获取电机保护温度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电机保护温度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 电机保护温度,单位℃\n\nC++: ActuatorController::getMotorProtectedTemperature(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setMotorProtectedTemperature", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setMotorProtectedTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("temp"));
		cl.def("setMotorProtectedTemperature", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setMotorProtectedTemperature, "设置电机保护温度\n \n\n 执行器id\n \n\n 电机保护温度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setMotorProtectedTemperature(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("temp"), pybind11::arg("ipAddress"));
		cl.def("getMotorRecoveryTemperature", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getMotorRecoveryTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getMotorRecoveryTemperature", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getMotorRecoveryTemperature, "获取电机恢复温度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次电机恢复温度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 电机恢复温度,单位℃\n\nC++: ActuatorController::getMotorRecoveryTemperature(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setMotorRecoveryTemperature", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setMotorRecoveryTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("temp"));
		cl.def("setMotorRecoveryTemperature", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setMotorRecoveryTemperature, "设置电机恢复温度\n \n\n 执行器id\n \n\n 电机恢复温度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setMotorRecoveryTemperature(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("temp"), pybind11::arg("ipAddress"));
		cl.def("getInverterProtectedTemperature", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getInverterProtectedTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getInverterProtectedTemperature", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getInverterProtectedTemperature, "获取逆变器保护温度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次逆变器保护温度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 逆变器保护温度,单位℃\n\nC++: ActuatorController::getInverterProtectedTemperature(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setInverterProtectedTemperature", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setInverterProtectedTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("temp"));
		cl.def("setInverterProtectedTemperature", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setInverterProtectedTemperature, "设置逆变器保护温度\n \n\n 执行器id\n \n\n 逆变器保护温度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setInverterProtectedTemperature(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("temp"), pybind11::arg("ipAddress"));
		cl.def("getInverterRecoveryTemperature", [](ActuatorController const &o, unsigned char const & a0, bool const & a1) -> double { return o.getInverterRecoveryTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("bRefresh"));
		cl.def("getInverterRecoveryTemperature", (double (ActuatorController::*)(unsigned char, bool, const std::string &) const) &ActuatorController::getInverterRecoveryTemperature, "获取逆变器恢复温度\n \n\n 执行器id\n \n\n 是否需要刷新，如果为true，会自动请求一次逆变器恢复温度,并等待返回，如果为false,则会立即返回最近一次请求位置返回的结果\n \n\n 目标ip地址字符串\n \n\n 逆变器恢复温度,单位℃\n\nC++: ActuatorController::getInverterRecoveryTemperature(unsigned char, bool, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("bRefresh"), pybind11::arg("ipAddress"));
		cl.def("setInverterRecoveryTemperature", [](ActuatorController &o, unsigned char const & a0, double const & a1) -> void { return o.setInverterRecoveryTemperature(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("temp"));
		cl.def("setInverterRecoveryTemperature", (void (ActuatorController::*)(unsigned char, double, const std::string &)) &ActuatorController::setInverterRecoveryTemperature, "设置逆变器恢复温度\n \n\n 执行器id\n \n\n 逆变器恢复温度\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::setInverterRecoveryTemperature(unsigned char, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("temp"), pybind11::arg("ipAddress"));
		cl.def("isOnline", [](ActuatorController const &o, unsigned char const & a0) -> bool { return o.isOnline(a0); }, "", pybind11::arg("id"));
		cl.def("isOnline", (bool (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::isOnline, "执行器是否在线\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 在线状态\n\nC++: ActuatorController::isOnline(unsigned char, const std::string &) const --> bool", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("isEnable", [](ActuatorController const &o, unsigned char const & a0) -> bool { return o.isEnable(a0); }, "", pybind11::arg("id"));
		cl.def("isEnable", (bool (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::isEnable, "执行器是否已经使能\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 是否使能\n\nC++: ActuatorController::isEnable(unsigned char, const std::string &) const --> bool", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("enableHeartbeat", [](ActuatorController const &o, unsigned char const & a0) -> void { return o.enableHeartbeat(a0); }, "", pybind11::arg("id"));
		cl.def("enableHeartbeat", (void (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::enableHeartbeat, "使能执行器心跳功能，使能后自动刷新执行器在线状态和错误（默认状态为使能）\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::enableHeartbeat(unsigned char, const std::string &) const --> void", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("disableHeartbeat", [](ActuatorController const &o, unsigned char const & a0) -> void { return o.disableHeartbeat(a0); }, "", pybind11::arg("id"));
		cl.def("disableHeartbeat", (void (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::disableHeartbeat, "失能执行器心跳功能，失能后关闭自动刷新执行器在线状态和错误\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::disableHeartbeat(unsigned char, const std::string &) const --> void", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("setActuatorID", [](ActuatorController &o, unsigned char const & a0, unsigned char const & a1) -> bool { return o.setActuatorID(a0, a1); }, "", pybind11::arg("currentID"), pybind11::arg("newID"));
		cl.def("setActuatorID", (bool (ActuatorController::*)(unsigned char, unsigned char, const std::string &)) &ActuatorController::setActuatorID, "设置执行器ID\n \n\n 当前执行器id\n \n\n 执行器新ID\n \n\n 目标ip地址字符串\n \n\n 是否修改成功\n\nC++: ActuatorController::setActuatorID(unsigned char, unsigned char, const std::string &) --> bool", pybind11::arg("currentID"), pybind11::arg("newID"), pybind11::arg("ipAddress"));
		cl.def("getActuatorSerialNumber", [](ActuatorController const &o, unsigned char const & a0) -> unsigned int { return o.getActuatorSerialNumber(a0); }, "", pybind11::arg("id"));
		cl.def("getActuatorSerialNumber", (unsigned int (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::getActuatorSerialNumber, "获取执行器序列号\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 执行器序列号\n\nC++: ActuatorController::getActuatorSerialNumber(unsigned char, const std::string &) const --> unsigned int", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("getActuatorMode", [](ActuatorController const &o, unsigned char const & a0) -> Actuator::ActuatorMode { return o.getActuatorMode(a0); }, "", pybind11::arg("id"));
		cl.def("getActuatorMode", (enum Actuator::ActuatorMode (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::getActuatorMode, "获取执行器当前模式\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 当前模式\n\nC++: ActuatorController::getActuatorMode(unsigned char, const std::string &) const --> enum Actuator::ActuatorMode", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("getErrorCode", [](ActuatorController const &o, unsigned char const & a0) -> unsigned int { return o.getErrorCode(a0); }, "", pybind11::arg("id"));
		cl.def("getErrorCode", (unsigned int (ActuatorController::*)(unsigned char, const std::string &) const) &ActuatorController::getErrorCode, "获取执行器错误代码\n \n\n 执行器id\n \n\n 目标ip地址字符串\n \n\n 错误代码\n\nC++: ActuatorController::getErrorCode(unsigned char, const std::string &) const --> unsigned int", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("regainAttribute", [](ActuatorController &o, unsigned char const & a0, unsigned char const & a1) -> void { return o.regainAttribute(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("attrId"));
		cl.def("regainAttribute", (void (ActuatorController::*)(unsigned char, unsigned char, const std::string &)) &ActuatorController::regainAttribute, "重新获取属性,将请求刷新属性\n \n\n 执行器id\n \n\n 执行器属性Id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::regainAttribute(unsigned char, unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("attrId"), pybind11::arg("ipAddress"));
		cl.def("getErrorHistory", [](ActuatorController &o, unsigned char const & a0) -> std::vector<unsigned short, class std::allocator<unsigned short> > { return o.getErrorHistory(a0); }, "", pybind11::arg("id"));
		cl.def("getErrorHistory", (class std::vector<unsigned short, class std::allocator<unsigned short> > (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::getErrorHistory, "获取执行器错误历史记录\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::getErrorHistory(unsigned char, const std::string &) --> class std::vector<unsigned short, class std::allocator<unsigned short> >", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("reconnect", [](ActuatorController &o, unsigned char const & a0) -> void { return o.reconnect(a0); }, "", pybind11::arg("id"));
		cl.def("reconnect", (void (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::reconnect, "执行器掉线重连\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::reconnect(unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("clearError", [](ActuatorController &o, unsigned char const & a0) -> void { return o.clearError(a0); }, "", pybind11::arg("id"));
		cl.def("clearError", (void (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::clearError, "执行器错误清除\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::clearError(unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("versionString", (std::string (ActuatorController::*)() const) &ActuatorController::versionString, "versionString 获取sdk版本号字符串\n \n\n sdk版本号字符串\n\nC++: ActuatorController::versionString() const --> std::string");
		cl.def("requestCVPValue", [](ActuatorController &o, unsigned char const & a0) -> void { return o.requestCVPValue(a0); }, "", pybind11::arg("id"));
		cl.def("requestCVPValue", (void (ActuatorController::*)(unsigned char, const std::string &)) &ActuatorController::requestCVPValue, "requestCVPValue 获取电流速度位置的值(如果同时需要三个值，该接口效率比较高）\n \n\n 执行器id\n \n\n 目标ip地址字符串\n\nC++: ActuatorController::requestCVPValue(unsigned char, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("ipAddress"));
		cl.def("addParaRequestCallback", (void (ActuatorController::*)(class std::function<void (struct ActuatorController::UnifiedID, unsigned char, double)>)) &ActuatorController::addParaRequestCallback, "addParaRequestCallback 增加参数请求回调函数，当参数请求返回结果后会触发回调\n \n\n 回调函数function\n\nC++: ActuatorController::addParaRequestCallback(class std::function<void (struct ActuatorController::UnifiedID, unsigned char, double)>) --> void", pybind11::arg("callback"));
		cl.def("addErrorCallback", (void (ActuatorController::*)(class std::function<void (struct ActuatorController::UnifiedID, unsigned short, std::string)>)) &ActuatorController::addErrorCallback, "addErrorCallback 增加错误回调函数，当执行器发生错误后会触发回调\n \n\n 回调函数function\n \n\n 当失能执行器heartbeat后，即调用disableHeartbeat后将不会上报错误\n\nC++: ActuatorController::addErrorCallback(class std::function<void (struct ActuatorController::UnifiedID, unsigned short, std::string)>) --> void", pybind11::arg("callback"));
		cl.def("clearCallbackHandlers", (void (ActuatorController::*)()) &ActuatorController::clearCallbackHandlers, "clearCallbackHandlers 清除所有回调\n\nC++: ActuatorController::clearCallbackHandlers() --> void");
		cl.def("setActuatorAttribute", (void (ActuatorController::*)(unsigned long, enum Actuator::ActuatorAttribute, double)) &ActuatorController::setActuatorAttribute, "C++: ActuatorController::setActuatorAttribute(unsigned long, enum Actuator::ActuatorAttribute, double) --> void", pybind11::arg("longId"), pybind11::arg("attrId"), pybind11::arg("value"));
		cl.def("setActuatorAttribute", [](ActuatorController &o, unsigned char const & a0, enum Actuator::ActuatorAttribute const & a1, double const & a2) -> void { return o.setActuatorAttribute(a0, a1, a2); }, "", pybind11::arg("id"), pybind11::arg("attrId"), pybind11::arg("value"));
		cl.def("setActuatorAttribute", (void (ActuatorController::*)(unsigned char, enum Actuator::ActuatorAttribute, double, const std::string &)) &ActuatorController::setActuatorAttribute, "C++: ActuatorController::setActuatorAttribute(unsigned char, enum Actuator::ActuatorAttribute, double, const std::string &) --> void", pybind11::arg("id"), pybind11::arg("attrId"), pybind11::arg("value"), pybind11::arg("ipAddress"));
		cl.def("getActuatorAttribute", (double (ActuatorController::*)(unsigned long, enum Actuator::ActuatorAttribute) const) &ActuatorController::getActuatorAttribute, "C++: ActuatorController::getActuatorAttribute(unsigned long, enum Actuator::ActuatorAttribute) const --> double", pybind11::arg("longId"), pybind11::arg("attrId"));
		cl.def("getActuatorAttribute", [](ActuatorController const &o, unsigned char const & a0, enum Actuator::ActuatorAttribute const & a1) -> double { return o.getActuatorAttribute(a0, a1); }, "", pybind11::arg("id"), pybind11::arg("attrId"));
		cl.def("getActuatorAttribute", (double (ActuatorController::*)(unsigned char, enum Actuator::ActuatorAttribute, const std::string &) const) &ActuatorController::getActuatorAttribute, "C++: ActuatorController::getActuatorAttribute(unsigned char, enum Actuator::ActuatorAttribute, const std::string &) const --> double", pybind11::arg("id"), pybind11::arg("attrId"), pybind11::arg("ipAddress"));

		{ // ActuatorController::UnifiedID file:actuatorcontroller.h line:43
			auto & enclosing_class = cl;
			pybind11::class_<ActuatorController::UnifiedID, std::shared_ptr<ActuatorController::UnifiedID>> cl(enclosing_class, "UnifiedID", "执行器唯一ID,由执行器ID(actuatorID)和执行器通信地址(ipAddress)组成\n \n\n 同一通信地址下的执行器ID不能重复，不同通信地址下的执行器ID可重复");
			cl.def( pybind11::init<unsigned char, std::string>(), pybind11::arg("id"), pybind11::arg("ip") );

			cl.def( pybind11::init( [](ActuatorController::UnifiedID const &o){ return new ActuatorController::UnifiedID(o); } ) );
			cl.def_readwrite("actuatorID", &ActuatorController::UnifiedID::actuatorID);
			cl.def_readwrite("ipAddress", &ActuatorController::UnifiedID::ipAddress);
		}

	}
}
